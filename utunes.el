;;; utunes.el --- Microscopic music library manager. -*- lexical-binding: t -*-

;; Copyright (C) 2019 Radon Rosborough

;; Author: Radon Rosborough <radon.neon@gmail.com>
;; Created: 30 Apr 2019
;; Homepage: https://github.com/raxod502/utunes
;; Keywords: applications
;; Package-Requires: ((emacs "26"))
;; Version: 0

;;; Commentary:

;; µTunes attempts to replace major functionality of a full-featured
;; music library manager such as iTunes with an absolute minimum
;; number of lines of code. The interface, as such, is designed to
;; maximize flexibility while minimizing implementation complexity and
;; number of abstractions.

;; Please see <https://github.com/raxod502/utunes> for more
;; information.

;;; Code:

;; To see the outline of this file, run M-x outline-minor-mode and
;; then press C-c @ C-t. To also show the top-level functions and
;; variable declarations in each section, run M-x occur with the
;; following query: ^;;;;* \|^(

(require 'array)
(require 'cl-lib)
(require 'json)
(require 'let-alist)
(require 'map)
(require 'subr-x)

(defgroup utunes nil
  "Emacs frontend for the microscopic music library manager."
  :group 'applications
  :prefix "utunes-")

(defcustom utunes-log-buffer-name "*utunes-log*"
  "Name of the buffer used for diagnostic output from µTunes commands."
  :type 'string)

(defun utunes--get-log-buffer ()
  "Return the buffer for diagnostic output from µTunes commands.
If the buffer does not exist, create it first."
  (if-let ((buf (get-buffer utunes-log-buffer-name)))
      buf
    (with-current-buffer (get-buffer-create utunes-log-buffer-name)
      (special-mode)
      (current-buffer))))

(defun utunes--capitalize (str)
  "Capitalize only the first character of STR."
  (if (string-empty-p str)
      str
    (concat (upcase (substring str 0 1)) (substring str 1))))

(defun utunes--process-sentinel (proc event)
  "Process sentinel for µTunes backend commands.
PROC is the process and EVENT is a string describing the event
that happened. See
<https://www.gnu.org/software/emacs/manual/html_node/elisp/Sentinels.html>."
  (unless (process-live-p proc)
    (with-current-buffer (utunes--get-log-buffer)
      (let ((inhibit-read-only t))
        (save-excursion
          (goto-char (point-max))
          (insert "[" (utunes--capitalize (string-trim event)) "]\n")))
      (if (= 0 (process-exit-status proc))
          (when utunes--last-callback
            (funcall utunes--last-callback))
        (message "µTunes backend command failed")
        (pop-to-buffer (current-buffer))
        (goto-char (point-max))))
    (setq utunes--current-process nil)))

(defvar utunes--last-process nil
  "µTunes process currently or last running.
Used to prevent running more than one µTunes command
concurrently.")

(defvar utunes--last-callback nil
  "µTunes callback for currently or last running process.")

(cl-defun utunes-command (&key args stdin stdout callback)
  "Run a µTunes backend command with given command-line ARGS.
ARGS should not include \"utunes\".

If provided, STDIN should be a buffer whose contents will be fed
to the command on stdin. Similarly, if provided, STDOUT should be
a buffer to whose contents the command will append from stdout.

If a µTunes command is already running, return an error.

If the µTunes command fails unexpectedly or due to user error,
display a message in the minibuffer and pop to the log buffer.

If CALLBACK is provided, call it with no arguments if the command
succeeds."
  (cl-block nil
    (when (process-live-p utunes--last-process)
      (error "µTunes process already running"))
    (with-current-buffer (utunes--get-log-buffer)
      (let ((args (cons "utunes" args))
            (inhibit-read-only t))
        (save-excursion
          (goto-char (point-max))
          (unless (= (point) (point-min))
            (insert "\n"))
          (insert "$ " (mapconcat #'shell-quote-argument args " ") "\n"))
        (condition-case _err
            (setq utunes--last-process
                  (make-process
                   :name "utunes"
                   :buffer stdout
                   :command args
                   :stderr (current-buffer)
                   :sentinel #'utunes--process-sentinel))
          (file-missing
           (insert "[Command not found]\n")
           (cl-return)))
        (setq utunes--last-callback callback)
        (set-process-sentinel (get-buffer-process (current-buffer))
                              #'ignore)
        (when stdin
          (with-current-buffer stdin
            (process-send-region
             utunes--last-process
             (point-min) (point-max))
            (process-send-eof utunes--last-process)))))))

(defvar utunes--scratch-buffer (get-buffer-create " *utunes-scratch*")
  "Buffer used for scratch work in spawning processes.")

(defun utunes--map-alist-keys (func alist)
  "Return a new alist generated by applying FUNC to each key of ALIST."
  (mapcar (lambda (link) (cons (funcall func (car link)) (cdr link)))
          alist))

(defun utunes--kebab-to-snake (alist)
  "Turn the keys in ALIST from kebab-case to snake_case.
Return a new alist, without modifying the original."
  (utunes--map-alist-keys
   (lambda (key)
     (intern (replace-regexp-in-string
              "-" "_" (symbol-name key))))
   alist))

(defun utunes--snake-to-kebab (alist)
  "Turn the keys in ALIST from snake_case to kebab-case.
Return a new alist, without modifying the original."
  (utunes--map-alist-keys
   (lambda (key)
     (intern (replace-regexp-in-string
              "_" "-" (symbol-name key))))
   alist))

(defun utunes-playback (input callback)
  "Invoke 'utunes playback' with the given INPUT alist.
The alist is turned into JSON and fed to µTunes on stdin. The
resulting JSON on stdout is decoded and turned back into an
alist. Then CALLBACK is invoked with the alist as its single
argument.

The keys of the input and output alists are symbols (`playlist',
`seek-end', etc.), and the values are either strings,
booleans (nil or t), integers, or floating-point numbers, as
appropriate. An empty alist (nil) is fine as input."
  (let* ((json-false nil)
         (json-null :json-null))
    (with-temp-buffer
      ;; json.el will mistake nil for false due to our settings above.
      ;; But we actually want nil (an empty alist) to turn into an
      ;; empty map. The following is an easy workaround.
      (insert (if input
                  (json-encode (utunes--kebab-to-snake input))
                "{}"))
      (let ((stdin (current-buffer)))
        (with-current-buffer utunes--scratch-buffer
          (erase-buffer)
          (utunes-command
           :args '("playback")
           :stdin stdin
           :stdout utunes--scratch-buffer
           :callback (lambda ()
                       (with-current-buffer utunes--scratch-buffer
                         (goto-char (point-min))
                         (funcall
                          callback (utunes--snake-to-kebab
                                    (json-read)))))))))))

(defun utunes-play ()
  "Start playback, or set state to playing if no track queued."
  (interactive)
  (utunes-playback
   '((playing . t))
   (lambda (resp)
     (let-alist resp
       (cond
        ((or (null .playlist) (null .index))
         (user-error "State set to playing, but no track queued"))
        (t
         (message "Now playing from playlist %S at index %S (%Ss/%Ss)"
                  .playlist .index (round .seek) (round .seek-end))))))))

(defun utunes-pause ()
  "Pause playback, or set state to paused if no track queued."
  (interactive)
  (utunes-playback
   '((playing . nil))
   (lambda (resp)
     (let-alist resp
       (cond
        ((null .seek)
         (user-error "State set to paused, but no track queued"))
        (t
         (message "Now paused in playlist %S at index %S (%Ss/%Ss)"
                  .playlist .index (round .seek) (round .seek-end))))))))

(defun utunes-skip (&optional toggle-play-pause)
  "Skip to next song. With prefix argument, toggle play/pause state."
  (interactive "P")
  (utunes-playback
   nil
   (lambda (resp)
     (let-alist resp
       (if .index
           (utunes-playback
            `((index . ,(1+ .index))
              (playing . ,(xor .playing toggle-play-pause)))
            (lambda (resp)
              (let-alist resp
                (message "Now %s in playlist %S at index %S"
                         (if .playing "playing" "paused")
                         .playlist .index)))))))))

;;;; Closing remarks

(provide 'utunes)

;; Local Variables:
;; indent-tabs-mode: nil
;; outline-regexp: ";;;;* "
;; End:

;;; el-patch.el ends here
